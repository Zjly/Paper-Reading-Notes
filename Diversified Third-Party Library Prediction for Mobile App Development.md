# Diversified Third-Party Library Prediction for Mobile App Development

### 研究背景

如今，移动应用的发展速度迅猛，其市场的竞争也十分的激烈。移动应用的红海市场使得开发人员需要尽快的编写、发布以及升级他们所开发的移动应用程序，而第三方库的引入大大提升了开发人员的开发效率。因此，开发人员需要一种能够根据已使用的第三方库，对将可能使用的第三方库进行推荐的方法。

现有的方法例如协同过滤算法可以根据已有的信息对未知的的信息进行推荐，协同过滤算法的基本思想是：如果两个应用程序$u$和$v$有相似的第三方库的使用记录，那么它们会对其他的第三方库有着相似的选择行为。

现有的基于协同过滤的方法可以被分为基于内存的协同过滤和基于模型的协同过滤：

+ 基于内存的协同过滤分为根据user的相似user进行推荐（UserCF）或者根据item的相似item（ItemCF）进行推荐，又或是将它们融合起来进行推荐。
+ 基于模型的方法会根据已有的user-item矩阵得到因子模型进行推荐，有聚类模型、方面模型（如矩阵分解）等模型。

矩阵分解在近年来受到了广泛使用，其效果与性能也得到了业界的认可。但是，矩阵分解所得到的推荐结果会出现一种流行度偏差问题。也就是说，一小部分被大量使用的第三方库占据了推荐结果的绝大部分，而大量的第三方库较少被使用。如图所示，前1%流行的库参与了29.91%的应用程序使用第三方库的记录：

![image-20210531013301567](https://raw.githubusercontent.com/Zjly/Image-hosting/master/202112301539395.png)

如下图的矩阵分解的推荐结果所示，长尾分布十分显著。黄色菱形代表训练集，是原本的应用程序-第三方库的使用情况；蓝色六角星代表测试集，是文章中将原本的应用程序-第三方库的使用情况所除去的、待推荐的一部分。可以看出他们遵从长尾分布，流行的第三方库被大量使用且大量的第三方库较少被使用。而红色五角星代表矩阵分解的推荐结果，可以看出推荐结果并未覆盖到所有的第三方库，而是仅仅推荐了极小部分的流行的第三方库。

![image-20210531014008903](https://raw.githubusercontent.com/Zjly/Image-hosting/master/202112301539409.png)

事实上，推荐一些经常被使用的第三方库是没有必要的，这些库早已被开发人员所熟知；而开发人员需要一种能够推荐一些新颖和偶然的、且符合应用程序使用库记录的第三方库。这些能够帮助开发人员获得更多的信息，解决流行度偏差问题，提高软件的开发效率。

### LeebSeek

论文中提出了一种新的基于矩阵分解的方法LeebSeek，它可以对应用程序所将要使用的第三方库进行多样化的推荐。它主要采用了两种方法来实现这个目的：

+ 通过对每个第三方库分配一个自适应权重，来增加流行度较高的库被推荐的代价
+ 在矩阵分解过程中引入邻域信息，使得推荐结果与邻域结果多样性增强

### 自适应权重

如图所示，矩阵$M$代表着应用程序与第三方库之间的使用关系。$r_{u,i}$代表着使用记录，“1”表示应用程序$u$使用了第三方库$i$，“0”表示应用程序$u$未使用第三方库$i$。

![image-20210601125516957](https://raw.githubusercontent.com/Zjly/Image-hosting/master/202112301539566.png)

在一般的矩阵分解计算中，仅用到了条目为“1”的信息，在计算中丢弃了条目为“0”的信息。但是，条目为“0”的信息不仅仅代表着用户不喜欢相应的第三方库，其中包含着没有被挖掘的有效信息，“0”有可能是因为各种不同的原因造成的。例如，在查找时开发人员有可能忽视了某些库的作用，又或是这些库的隐私政策使得某些开发人员对其的意愿降低。因此，“0”条目中包含着关于有效的隐信息，可以充分利用到矩阵分解的计算之中。所以为了充分利用到隐信息，LeebSeek对显信息与隐信息都进行了建模，来进行第三方库的推荐。

为了解决流行度偏差问题，LeebSeek引入了一种自适应加权机制，它会根据第三方库的流行程度自适应的分配权重。给予流行的第三方库较低的权重，给予不太流行的第三方库更高的权重，以便在矩阵分解中解决流行度偏差的问题。

LeebSeek的损失函数如公式1所示：

$$\mathop{min}\limits_{X,Y}Loss=\sum_\limits{u=1}^{m}\sum_\limits{i=1}^{n}w_{u,i}(r_{u,i}-x^T_uy_i)^2+\lambda(\sum_\limits{u=1}^{m}\|x_u\|^2+\sum_\limits{i=1}^{n}\|y_i\|^2) \tag{1}$$

其中，$r_{u,i}-x^T_uy_i$为真实值和预测值之间的偏差，$\lambda(\sum_\limits{u=1}^{m}\|x_u\|^2+\sum_\limits{i=1}^{n}\|y_i\|^2)$为正则化项，$w_{u,i}$为自适应权重，其根据应用程序的第三方库使用情况分配一个权重来解决流行度偏差问题，$w_{u,i}$的计算方式如公式2所示：

$$w_{u,i}=\begin{cases}1& r_{u,i}=0\\1+weight/(1+\ln p_i)& r_{u,i}=1\end{cases} \tag{2}$$ 

其中，$weight$为手动设置的参数，用于控制条目“1”的重要性。$p_i$为第三方库的使用次数，被使用次数越多的第三方库的$p_i$会越大，这会导致自适应权重的值降低，使得其被继续推荐的代价增加。

LeebSeek提出了自适应权重这一参数来控制第三方库的被选择次数，使得一些常用的第三方库被继续推荐给开发人员的代价增加，这样能够让一些较少被推荐的第三方库加入到最后的推荐列表中，丰富了开发人员的选择范围，在一定范围内解决了流行度偏差的问题。

### 邻域信息

在基本的协同过滤之中，算法能够利用到应用程序的邻域信息，也就是说能够根据获取到的与应用程序$u$所相似的程序$u_n$的第三方库使用信息，对应用程序$u$进行第三方库的推荐。但是，在矩阵分解中，邻域信息并没有被显式的运用到计算之中。LeebSeek运用应用程序的邻域信息，寻找到应用程序$u$的邻域$N_A(u)$和第三方库的邻域$N_L(i)$，并以它们为基础来解决流行度偏差的问题。

首先，LeebSeek会计算出应用程序$u$和其他每个应用程序之间的相似性，并计算出第三方库$i$和其它每个第三方库之间的相似性。它们之间的相似性使用Jaccard Correlation Coefficient来计算，其计算方式如公式3和4所示：

$$SimApp(u,v)=\frac{\sum_{l\in L}r_{u,l}\times r_{v,l}}{\sum_{l\in L}(r_{u,l} + r_{v,l} - r_{u,l}\times r_{v,l})} \tag{3}$$

$$SimLib(i,j)=\frac{\sum_{u\in A}r_{u,i}\times r_{u,j}}{\sum_{u\in A}(r_{u,i} + r_{u,j} - r_{u,i}\times r_{u,j})} \tag{4}$$

上述公式是对两个应用程序或是第三方库之间相似度的计算，也就是对矩阵$M$内行或列之间的相似度进行计算。以行相似度为例，当它们在同一个列索引都为1或是0时，也就是它们“相同”时，分子与分母都加上了1，这相当于提供了一部分的相似度；它们在同一个列索引下一个为1一个为0时，也就是它们“不同”时，分子不变分母加上了1，这相当于提供了一部分的相异度。

之后，LeebSeek会选择与$u$最相似的k个应用程序作为$u$的邻域，选择与$i$最相似的k个第三方库作为$i$的邻域。对不同邻域之间进行正则化，其计算方式如公式5和6所示：

$$Sa(u,v)=\frac{SimApp(u,v)}{\sum_{r\in N_A(u)}SimApp(u,r)}\tag{5}$$

$$Sl(i,j)=\frac{SimLib(i,j)}{\sum_{k\in N_L(i)}SimLib(i,k)}\tag{6}$$

最后，将邻域信息加入到矩阵分解的损失函数中，最终的损失函数如公式7所示：

$$\mathop{min}\limits_{X,Y,N_A,N_L}Loss=\sum_\limits{u=1}^{m}\sum_\limits{i=1}^{n}w_{u,i}(r_{u,i}-x^T_uy_i)^2+\lambda(\sum_\limits{u=1}^{m}\|x_u\|^2+\sum_\limits{i=1}^{n}\|y_i\|^2)\\+\alpha\sum_\limits{u=1}^{m}\sum_\limits{v\in N_A(u)}Sa(u,v)\|x_u-x_v\|^2+\alpha\sum_\limits{i=1}^{n}\sum_\limits{j\in N_L(i)}Sl(i,j)\|y_i-y_j\|^2 \tag{7}$$

其中，参数$\alpha$控制推荐结果对于邻域信息的依赖程度，LeebSeek利用邻域信息的能力会随着$\alpha$的增加而增加。后续论文中对$x_u$和$y_i$求取了偏导数，进行进一步的计算，由于篇幅所限且不是解决流行度偏差的要点，这里就不在赘述。

LeebSeek引入了邻域信息，使得在计算过程中能够获取到当前应用程序或是第三方库的邻域信息。加入了邻域信息之后，能够利用它们之间的相似程度来减少同样内容的被推荐，提升了推荐结果的多样性，丰富了开发人员的选择范围，在一定范围内解决了流行度偏差的问题。

### 总结

Leebseek主要从两个方面来解决流行度偏差的问题，一是加入对高流行度第三方库被选择的惩罚，二是在矩阵分解中引入邻域信息增加推荐结果的多样性。根据实验对比可见，LeebSeek取得了较好的效果，明显优于现有的几种代表性的推荐方法。

